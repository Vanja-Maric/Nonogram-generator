# Kapitel 2
| Namn och förklarning | Reflektion och regler från Clean Code |
| -------- | -------- |
| Klassnamn __BlackWhiteCellCounts__ | __Use Pronounceable Names__ - Jag har funderat på att förkorta namnet på klassen BWCellCounts för att det inte ska bli för långt. Men då blev namnet väldigt svårt att uttala, och det krävde till och med en kommentar för att förklara vad BW betyder. Därför bestämde jag mig för att namnge klassen "BlackWhiteCellCounts".| 
| | __Class Names__ - Jag funderade på att lägga till ordet "Processor" eller "Generator" i namnet, men klassnamnet bör inte innehålla ett verb. Men en annan klass som jag skapade heter "GridGetter", eftersom jag tror att endast namnet "Grid" inte ger tillräcklig information om klassens syfte, och här är det ett undantag där "getter" passar bra.|
| Metodnamn __getAllRowsBlackCellCounts()__ | __Intention revealing names__ - För att undvika onödiga kommentarer som förklarar metodnamn har jag valt att använda ett något längre namn för metoden som helt och hållet avslöjar dess avsikt. |
|| __Method Names__ - "Accessors, mutators, and predicates should be named for their value and prefixed with get, set, and is according to the javabean standard."|
| Metodnamn __getCellCountsColumns()__ | __Don’t Add Gratuitous Context__ - Metoden ligger i en klass som heter "RedGreenBlueCellCounts". Jag har funderat på att namnge metoden "getRGBCellCountsColumns" för att betona att den hämtar cellräkningar för röda, gröna och blåa celler. Eftersom klassen redan betonar att den hanterar röda, gröna och blåa cellräkningar, känns det onödigt att inkludera "RGB" i metodnamnet.|
| Metodnamn __getCountsColorsRows()__ | __Avoid Disinformation__ - Tidigare hade jag namngett den här metoden "getColorsofCountsRows," och en annan metod i samma klass hade namnet "getColorCountsRows." Det blev mycket svårt att särskilja dem. För att undvika förvirring och felaktig information valde jag att namnge den här metoden om till "getCountsColorsRows," vilket markant underlättade att skilja den från den andra metoden. Jag ändrade namnet till andra metoden till "getCellCountsRows" - valde att ta bort colors för att det framkommer redan från klassnamnet.|
| int __rowIndex__ | ```for (int rowIndex = 0; rowIndex < numberOfRows; rowIndex++)``` __Use Intention-Revealing Names__ - Eftersom jag använder rowIndex på några ställen i denna for-loop, övervägde jag att ge den heltalsvariabel som används i for-loopen ett meningsfullt och avsiktsavslöjande namn istället för att bara använda en enda bokstav som 'i'.|
| | __Use Searchable Names__ - "rowIndex" blir mycket lättare att hitta i koden än "i".|


I kapitel 2 av boken har författaren utförligt diskuterat principer och riktlinjer för namngivning inom programutveckling. Det har varit en ögonöppnare och har fått mig att tänka mer kritiskt på hur jag tidigare har namngivit variabler, funktioner och klasser i min kod. I denna kappitel finns inte några principer som jag tycker är orymliga.

Jag anser principen "Klara och Tydliga Namn" som grundläggande princip. Namn bör tydligt besvara grundläggande frågor som varför de existerar, vad de gör och hur de används. Det är viktigt att de svarar på dessa frågor på ett sådant sätt att kommentarer inte behövs. Min tidigare praxis när det gäller namngivning var ganska bristfällig. Jag gav ofta variabler och funktioner namn som dök upp i mitt huvud först och jag har föredragit korta namn, men principen om att Undvika Desinformation inspirerade mig att använda längre namn som noggrant beskriver innehållet. På så sätt, med ett längre och beskrivande namn, blev det lättare att undvika sidoefekter som kan dyka upp om man har väldigt kort namn som beskriver bara en av flera saker som funktionen gör.

Genom att tillämpa principen Välj Ett Ord per Koncept och använda ett Konsekvent Lexikon kan det lätt hända att flera metoder har liknande namn. Detta kan leda till förväxling, användning av fel metod istället för den avsedda, eller att läsning i kodgranskning misstas för att vara en annan metod. Även stavfel i liknande begrepp kan leda till förväxling. För att undvika detta kan namn ändras genom att lägga till nya detaljer i namnen för att göra dem unika. Det är inte heller lämpligt att ge synonymer till en metod bara för att undvika liknande namn för två olika metoder. För att underlätta för andra programmerare som läser koden är det nödvändigt att tillämpa principen Skapa Meningsfulla Distinktioner: Om två saker har olika namn bör de också ha olika betydelser. Använd inte samma namn för två olika saker.

Att också tillämpa principerna "Kortare Namn Är Vanligtvis Bättre" och "Undvika Onödig Kontext" kan vara lite utmanande om man samtidigt vill använda principer för noggrant beskrivande namn, som jag redan nämnde. Man ska hitta rätt balans. Det är viktigt att använda bra beskrivande namn som inte är för långa men ändå tydligt beskriver vad metoden gör. Jag strävar efter att använda kortare namn när de fortfarande är tillräckligt beskrivande för att förstås utan att behöva gräva djupt in i koden.

Principen "Användbara och Sökbara Namn" säger att namn bör vara lätt sökbara. Längden på namnen bör motsvara deras användningsområde. I alla for-loopar har jag tidigare bara använt ett enda bokstav för variabelnamnen (till exempel, "in i = 10; i > 5..."). Efter att ha läst den här boken har jag börjat använda längre namn inuti for-loopar i vissa fall (till exempel, "for int row = 0; row < maxRows...") för att koden innom förlopen blir mycket tydligare när man har mer information om iterering. Ibland är det dock fortfarande onödigt, som när variabeln inte används vidare inom for-loopen (till exempel, "for(int i = 0; i<5; i++) {count++ }"). Att undvika magiska nummer, som numret 5 i "i<5", hjälper också till att förbättra kodkvaliteten. Att deklarera variabeln, till exempel "int numberOfDays = 5;", och sedan använda den i loopen (som i "for(int i = 0; i < numberOfDays ; i++) {count++ }"), blir en mycket bättre lösning.

Sammanfattningsvis har kapitel 2 i boken gett mig värdefulla insikter och riktlinjer för att förbättra min namngivning i koden. Jag känner att jag nu har en djupare förståelse för vikten av tydliga och beskrivande namn och hur de kan göra min kod mer läsbar och underhållbar. Jag ser fram emot att tillämpa dessa principer i mitt framtida arbete som programmerare.

#Kapitel 3
| Metodnamn och länk eller kod | Antal rader | Reflektion |
| -------- | -------- | -------- |
|[getOneColorCellCountsInOneLine(String[] lineToAnalyse, String color) - från line 55](https://github.com/Vanja-Maric/Nonogram-generator/blob/main/src/nonogram/RedGreenBlueCellCounts.java)| 36 | __Blocks and Indenting__ - "This implies that the blocks within if statements, else statements, while statements, and so on should be one line long. Probably that line should be a function call." Jag tänkte att detta är lite för extremt och att det skulle bli mycket vertikalt skrollande om jag gör så. MEN, eftersom den här metoden har väldigt många if-satser, inser jag nu att det vore mycket bättre om de separerades i egna metoder. På det sättet skulle de ha beskrivande namn och alla kommentarer som finns nu skulle bli onödiga.|
||| __Small!__ - "Functions should hardly ever be 20 lines long." - Om jag applicerar principen som jag nämnde tidigare, "Blocks and Indenting", skulle denna funktion bli mycket mindre. |
|||__Command Query Separation__ - CQS är i viss mån uppfylld - Den främsta syftet med denna metod är att beräkna och returnera en lista över färgantal baserat på argument. Men jag kunde separera felhantering i en separat metod.
||| __Prefer Exceptions to Returning Error Codes__ - använder Exception |
|[determineRedGreenBlueWhiteCell(int cell, Color red, Color green, Color blue) - från line 131](https://github.com/Vanja-Maric/Nonogram-generator/blob/main/src/nonogram/GridGetter.java)| 17 | __Function Arguments__ - Enligt principerna för "Clean Code" bör man inte ha fyra argument i en metod. Jag har funderat mycket på att inte ta in Color-attributer och istället skapa dem som variabler inuti metoden. I denna metod har jag dock valt att ha fyra argument eftersom denna funktion kommer att anropas för varje cell i ett nonogramspel. Om jag skapar tre färger varje gång funktionen anropas kan det fungera bra för en nonogram-grid med 30 rader och 30 kolumner. Men vad händer om man vill ha en nonogram-grid med 500 rader och 500 kolumner? Då skapas det väldigt många Color-klasser, och i det fallet tycker jag att det är bättre att ta in dem som argument. |
||| __Have No Side Effects__ - Metoden har inga sidoeffekter. Den gör bara den sak som är beskriven i namnet. |
|[getBlackCellCountsInOneLine( String[] lineToAnalyse) - från line 56](https://github.com/Vanja-Maric/Nonogram-generator/blob/main/src/nonogram/BlackWhiteCellCounts.java)| 23 |__Common Monadic Forms__ - Vanligt Monadic - Metoden tar in en argument, använder den för att få och returnera något annnat. |
||| __Verbs and Keywords__ - Namnet på den här metoden, 'getBlackCellCountsInOneLine,' och dess parameter 'lineToAnalyse,' bildar en mycket bra 'verb/noun pair,' vilket gör koden lättare att förstå.|
|[getCellCountsForAllRowsOrColumns(ArrayList<ArrayList<Integer>> redCountsinAllRowsOrColumns, ArrayList<ArrayList<Integer>> greenCountsInAllRowsOrColumns; ArrayList<ArrayList<Integer>> blueCountsInAllRowsOrColumns) - från line 98](https://github.com/Vanja-Maric/Nonogram-generator/blob/main/src/nonogram/RedGreenBlueCellCounts.java)| 22 | __Triads__ - Metod tar in 3 arguments. Vid metodanrop använder jag andra metoder som arguments. Då blir koden väldigt svårt att förstå. Jag kunde istället ha inga argumenter alls och argumenter som jag har nu kunde jag anropa som variabler inom metoden.  Also metodnamn tillsammans med argument är väldigt långa och måste brytas ner på flera rader, vilket kan skapa förvirring och sämre kodförståelse. |
||| __Output Arguments__ -  man bör undvika dem. Alla mina argument är input-argument.|
|[getColumnCellCountsForOneColor(String color) - från line 16](https://github.com/Vanja-Maric/Nonogram-generator/blob/main/src/nonogram/RedGreenBlueCellCounts.java)|15| __Small!__ - Metoden har färre än 20 rader. Men om man vill att alla metoder ska ha högst 4 rader, då skulle man kunna dela upp de nästlade looparna i två loopar. Första loopen skulle returnera en ArrayList som sedan skulle användas som antingen ett argument eller kallas som en variabel i den andra loopen. Båda dessa for-loopar skulle kunna separeras i egna metoder. |


I boken finns det väldigt många bra principer, så länge man använder dem lagom. Till exempel, den första principen som heter "Små!" säger att det är bäst om alla metoder är max 4 rader långa. Man ska nå detta genom att använda principen "Gör en sak" - varje metod/funktion ska bara göra en enda sak. Det är väldigt extremt. Då kommer vi få väldigt många kodrader på slutet, och det blir väldigt mycket vertikal scrolling. Ändå blir detta lättare om man använder "The stepdown rule" - Läs kod uppifrån till botten, där man kan enkelt läsa programmet genom att stiga ner genom listan med funktioner, där varje funktion bör följas av de på nästa abstraktionsnivå. Jag tycker att det är lite för strikt. Den andra regeln som säger att en metod inte bör ha mer än 20 rader kod låter mer rimlig. På det sättet förblir koden tillräckligt kort så att man undviker scrollning.

Principerna kring "Function Arguments" från boken är mycket bra, och regeln att man inte ska ha mer än 3 argument är mycket rimlig och kan förbättra kodkvaliteten. Men jag tycker ändå att det kan finnas undantag ibland om det skulle förbättra prestandan.

Tidigare har jag trott att kortare kod betyder bättre programmering, så jag bröt mot principen "Command Query Separation" oftare än jag borde, eftersom man kanske känner sig smartare om man skriver mindre kod. Så mina funktioner gjorde många saker samtidigt - utförde en handling och returnerade ett resultat samtidigt. Men detta gjorde koden mycket svårläst och extremt svår att förstå. Jag anser nu att användningen av COS (Command Query Separation) är en av de viktigare principerna.

När jag läste riktlinjer för att separera felhanterins kod tänkte jag direkt att det blir helt onödigt för att det är lättare tex om man ser erroren som kastas direkt i metoden som den handlar om. Ju mer jag tänker på det, och tittar på min kod låter dem allt rimligare att separera felhanterig. Att flytta try/catch-blocken ochkoden som kastar Errors till egna funktioner gör koden mer organiserad och enklare att förstå.

Många av dessa extrema principer kan kännas enkla och bra i teorin, men i praktiken finns det många andra faktorer att tänka på, som prestanda, problemens komplexitet och tidsbrist att rensa upp koden i efterhand.




# Min reflektion 
Jag har nu fått en insikt i skillnaden mellan ren och dålig kod, och det har varit en ögonöppnare. Tidigare trodde jag att koden jag skrev för en annan kurs (1dv613) var helt acceptabel, men nu ser jag allt jag gjorde fel. Jag hade enorma funktioner som försökte göra många saker samtidigt. Oftast hade funktionerna "side effects" också. Dessa funktioner hade namn som endast beskrev en del av vad de faktiskt gjorde. Jag inser nu det var förmodligen ganska svårt för andra programerare att läsa denna kod. I större projekt (som i kursen 1dv613 som jag precis nämnde) blir det betydligt svårare att hålla koden ren än i den lilla nonogram modulen som jag gjorde och man måste vara mycket försiktig med val av namn, storlek på funktioner, tycker jag.

En viktig lärdom jag har fått är att ändra variabelnamn i efterhand. Tidigare var jag rädd för att göra det. I en klass hade jag till exempel två metoder med namnen getColorsOfCellCounts och getColorCellCounts. Jag insåg ganska tidigt att de var alltför lika varandra, och när jag började skriva test applikation blev det ännu tydligare att de var för lätta att förväxla. Trots att jag insåg detta tvekade jag att ändra namnen. Till sist ändrade jag namnen, och det blev genast mycket lättare att skilja på dem. Jag har lärt mig hur viktigt det är att ha bra namn och att inte vara rädd att ändra dem om de inte är bra nog.

Jag har också märkt att mina metoder nu är betydligt kortare än vad jag brukade skriva tidigare. Trots detta känner jag att det finns mycket kvar som kan förbättras.

Innan jag började skriva den här modulen läste jag kapitel 2 och 3 från kurslitteraturen. Under tiden jag kodade kände det som om jag tillämpade principer som beskrivs i boken. Men efter att jag var klar insåg jag att det fortfarande fanns många områden där jag kunde och borde förbättra min kod. Efter att ha gått igenom och fixat dessa områden läste jag boken igen, och det kändes som om det fanns ännu fler sätt att förbättra min kod på. Det har blivit tydligt för mig att man alltid kan göra något bättre när det kommer till kod kvalitet.

Sammanfattningsvis har jag nu en mycket bättre förståelse för vikten av ren kod och hur man kan uppnå det. Jag har lärt mig att vara modig nog att ändra variabelnamn och att metoder bör vara korta och fokuserade. Det är en resa som jag ser fram emot att fortsätta, och jag tror att min kodkvalitet kommer att fortsätta att förbättras med tiden.